{
  
    
        "post0": {
            "title": "",
            "content": "Surprisal . Surprisal: $- frac{1}{log(p)}$ . #collapse_hide sns.set(style=&quot;darkgrid&quot;) probability = np.arange(0.01, 1.00, 0.01) surprisal = -np.log2(probability) df = pd.DataFrame(dict(x=probability,y=surprisal)) ax = sns.lineplot(x=&quot;x&quot;, y=&quot;y&quot;,data=df) ax.set(xlabel=&#39;Probability&#39;, ylabel=&#39;Surprisal&#39;) ax.annotate( &#39;The sun will rise tommorow -not surprising&#39;, xy=(1.0,0), xytext=(0.6, 1),size=&#39;small&#39;, arrowprops=dict(facecolor=&#39;black&#39;, shrink=0.05) ) ax.annotate( &#39;The world will end tommorow - very surprising&#39;, xy=(0,6), xytext=(0.1,6),size=&#39;small&#39;, arrowprops=dict(facecolor=&#39;black&#39;, shrink=0.05) ) plt.show() . . Entropy . Entropy: $- sum_{i=1}^{n} p_i frac{1}{log(p_i)}$ .",
            "url": "https://qwyeow.github.io/ml_blog/2020/03/22/2020-03-23-crossentropy.html",
            "relUrl": "/2020/03/22/2020-03-23-crossentropy.html",
            "date": " • Mar 22, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "fastai and the New DataBlock API",
            "content": ". This blog is also a Jupyter notebook available to run from the top down. There will be code snippets that you can then run in any environment. In this section I will be posting what version of fastai2 and fastcore I am currently running at the time of writing this: . fastai2: 0.0.13 . | fastcore: 0.1.15 . | . . What is the DataBlock API? . The DataBlock API is certainly nothing new to fastai. It was here in a lesser form in the previous version, and the start of an idea. This idea was: &quot;How do we let the users of the fastai library build DataLoaders in a way that is simple enough that someone with minimal coding knowledge could get the hang of it, but be advanced enough to allow for exploration.&quot; The old version was a struggle to do this from a high-level API standpoint, as you were very limited in what you could do: variables must be passed in a particular order, the error checking wasn&#39;t very explanatory (to those unaccustomed to debugging issues), and while the general idea seemed to flow, sometimes it didn&#39;t quite work well enough. For our first example, we&#39;ll look at the Pets dataset and compare it from fastai version 1 to fastai version 2 . The DataBlock itself is built on &quot;building blocks&quot;, think of them as legos. (For more information see fastai: A Layered API for Deep Learning) They can go in any order but together they&#39;ll always build something. Our lego bricks go by these general names: . blocks | get_items | get_x/get_y | getters | splitter | item_tfms | batch_tfms | . We&#39;ll be exploring each one more closely throughout this series, so we won&#39;t hit on all of them today . Importing from the library . The library itself is still split up into modules, similar to the first version where we have Vision, Text, and Tabular. To import from these libraries, we&#39;ll be calling their .all files. Our example problem for today will involve Computer Vision so we will call from the .vision library . from fastai2.vision.all import * . Pets . Pets is a dataset in which you try to identify one of 37 different species of cats and dogs. To get the dataset, we&#39;re going to use functions very familiar to those that used fastai version 1. We&#39;ll use untar_data to grab the dataset we want. In our case, the Pets dataset lives in URLs.PETS . URLs.PETS . &#39;https://s3.amazonaws.com/fast-ai-imageclas/oxford-iiit-pet.tgz&#39; . path = untar_data(URLs.PETS) . Looking at the dataset . When starting to look at adapting the API for a particular problem, we need to know just how the data is stored. We have an image problem here so we can use the get_image_files function to go grab all the file locations of our images and we can look at the data! . fnames = get_image_files(path/&#39;images&#39;) . To investigate how the files are named and where they are located, let&#39;s look at the first one: . fnames[0] . Path(&#39;/root/.fastai/data/oxford-iiit-pet/images/pug_119.jpg&#39;) . Now as get_image_files grabs the filename of our x for us, we don&#39;t need to include our get_x here (which defaults to None) as we just want to use this filepath! Now onto our file paths and how they relate to our labels. If we look at our returned path, this particular image has the class of pug. . Where do I see that? . Here: Path(&#39;/root/.fastai/data/oxford-iiit-pet/images/pug_119.jpg&#39;) . All the images follow this same format, and we can use a Regular Expression: to get it out. In our case, it would look something like so: . pat = r&#39;([^/]+)_ d+.*$&#39; . How do we know it worked? Let&#39;s apply it to the first file path real quick with re.search where we pass in the pattern followed by an item to try and find a match in the first group (set of matches) with a Regular Expression . re.search(pat, str(fnames[0])).group(1) . &#39;pug&#39; . We have our label! So what parts do we have so far? We know how to grab our items (get_items and get_x), our labels (get_y), what&#39;s left? Well, we&#39;ll want some way to split our data and our data augmentation. Let&#39;s focus on the prior. . Splitting and Augmentation . Any time we train a model, the data must be split between a training and validation dataset. The general idea is that the training dataset is what the model adjusts and fits its weights to, while the validation set is for us to understand how the model is performing. fastai2 has a family of split functions to look at that will slowly get covered throughout these blogs. For today we&#39;ll randomly split our data so 80% goes into our training set and 20% goes into the validation. We can utilize RandomSplitter to do so by passing in a percentage to split by, and optionally a seed as well to get the same validation split on multiple runs . splitter = RandomSplitter(valid_pct=0.2, seed=42) . How is this splitter applied? The splitter itself is a function that we can then apply over some set of data or numbers (an array). It works off of indexes. What does that look like? Let&#39;s see: . splitter(fnames) . ((#5912) [5643,5317,5806,3460,613,5456,2968,3741,10,4908...], (#1478) [4512,4290,5770,706,2200,4320,6450,501,1290,6435...]) . That doesn&#39;t look like filenames! Correct, instead its the location in our list of filenames and what group it belongs to. What this special looking list (or L) also tells us is how many items are in each list. In this example, the first (which is our training data) has 5,912 samples and the second (which is our validation) contains 1,478 samples. . Now let&#39;s move onto the augmentation. As noted earlier, there are two kinds: item_tfms and batch_tfms. Each do what it sounds like: an item transform is applied on an individual item basis, and a batch transform is applied over each batch of data. The role of the item transform is to prepare everything for a batch level (and to apply any specific item transformations you need), and the batch transform is to further apply any augmentations on the batch level efficently (normalization of your data also happens on a batch level). One of the biggest differences between the two though is where each is done. Item transforms are done on the CPU while batch transforms are performed on the GPU. . Now that we know this, let&#39;s build a basic transformation pipeline that looks something like so: . Resize our images to a fixed size (224x224 pixels) | After they are batched together, choose a quick basic augmentation function | Normalize all of our image data | Let&#39;s build it! . item_tfms = [Resize(224, method=&#39;crop&#39;)] batch_tfms=[*aug_transforms(size=256), Normalize.from_stats(*imagenet_stats)] . Woah, woah, woah, what in the world is this aug_transforms thing you just showed me I hear you ask? It runs a series of augmentations similar to the get_transforms() from version 1. The entire list is quite exhaustive and we&#39;ll discuss it in a later blog, but for now know we can pass in an image size to resize our images to (we&#39;ll make our images a bit larger, doing 256x256). . Alright, we know how we want to get our data, how to label it, split it, and augment it, what&#39;s left? That block bit I mentioned before. . The Block . Block&#39;s are used to help nest transforms inside of pre-defined problem domains. . Lazy-man&#39;s explaination? . If it&#39;s an image problem I can tell the library to use Pillow without explicitly saying it, or if we have a Bounding Box problem I can tell the DataBlock to expect two coordinates for boxes and to apply the transforms for points, again without explicitly saying these transforms. . What will we use today? Well let&#39;s think about our problem: we are using an image for our x, and our labels (or y&#39;s) are some category. Is there blocks for this? Yes! And they&#39;re labeled ImageBlock and CategoryBlock! Remember how I said it just &quot;made more sense?&quot; This is a direct example. Let&#39;s define them: . blocks = (ImageBlock, CategoryBlock) . Now let&#39;s build this DataBlock thing already! . Alright we have all the pieces now, let&#39;s see how they fit together. We&#39;ll all wrap them up in a nice little package of a DataBlock. Think of the DataBlock as a list of instructions to do when we&#39;re building batches and our DataLoaders. It doesn&#39;t need any items explicitly to be done, and instead is a blueprint of how to operate. We define it like so: . block = DataBlock(blocks=blocks, get_items=get_image_files, get_y=RegexLabeller(pat), splitter=splitter, item_tfms=item_tfms, batch_tfms=batch_tfms) . Once we have our DataBlock, we can build some DataLoaders off of it. To do so we simply pass in a source for our data that our DataBlock would be expecting, specifically our get_x and get_y, so we&#39;ll follow the same idea we did above to get our filenames and pass in a path to the folder we want to use along with a batch size: . dls = block.dataloaders(path, bs=64) . While it&#39;s a bit long, you can understand why we had to define everything the way that we did. If you&#39;re used to how fastai v1 looked with the ImageDataBunch.from_x, well this is stil here too: . dls = ImageDataLoaders.from_name_re(path, fnames, pat, item_tfms=item_tfms, batch_tfms=batch_tfms, bs=64) . I&#39;m personally a much larger fan of the first example, and if you&#39;re planning on using the library quite a bit you should get used to it more as well! This blog series will be focusing on that nomenclature specifically. To make sure everything looks okay and we like our augmentation we can show a batch of images from our DataLoader. It&#39;s as simple as: . dls.show_batch() . Fitting a Model . Now from here everything looks and behaves exactly how it did in fastai version 1: . Define a Learner | Find a learning rate | Fit | We&#39;ll quickly see that fastai2 has a quick function for transfer learning problems like we are doing, but first let&#39;s build the Learner. This will use cnn_learner, as we are doing transfer learning, and we&#39;ll tell the function to use a resnet34 architecture with accuracy metrics . learn = cnn_learner(dls, resnet34, metrics=accuracy) . Now normally we would do learn.lr_find() and find a learning rate, but with the new library, we now have a fine_tune() function we can use instead specifically designed for transfer learning scenarios. It runs a specified number of epochs (the number of times we fully go through the dataset) on a frozen model (where all but the last layer&#39;s weights are not trainable) and then the last few will be on an unfrozen model (where all weights are trainable again). When just passing in one set of epochs, like below, it will run frozen for one and unfrozen for the rest. Let&#39;s try it! . learn.fine_tune(3) . epoch train_loss valid_loss accuracy time . 0 | 1.488222 | 0.331919 | 0.893099 | 00:42 | . epoch train_loss valid_loss accuracy time . 0 | 0.471458 | 0.363768 | 0.890392 | 00:43 | . 1 | 0.368975 | 0.250430 | 0.926252 | 00:43 | . 2 | 0.205113 | 0.215602 | 0.935047 | 00:44 | . As we can see we did pretty goood just with this default! Generally when the accuracy is this high, we want to turn instead to error_rate for our metric, as this would show ~6.5% and is a better comparison when it gets very fine tuned. . But that&#39;s it for this first introduction! We looked at how the Pets dataset can be loaded into the new high-level DataBlock API, and what it&#39;s built with. In the next blog we will be exploring more variations with the DataBlock as we get more and more creative. Thanks for reading! .",
            "url": "https://qwyeow.github.io/ml_blog/datablock/2020/03/21/DataBlockAPI.html",
            "relUrl": "/datablock/2020/03/21/DataBlockAPI.html",
            "date": " • Mar 21, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # Title &gt; Awesome summary - toc: true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://qwyeow.github.io/ml_blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://qwyeow.github.io/ml_blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://qwyeow.github.io/ml_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}